"use strict";(self.webpackChunkcrossplatformkorea_com=self.webpackChunkcrossplatformkorea_com||[]).push([[115],{2488:function(e,n,s){s.r(n),s.d(n,{assets:function(){return l},contentTitle:function(){return c},default:function(){return u},frontMatter:function(){return a},metadata:function(){return i},toc:function(){return d}});var r=s(5893),t=s(1151),o=s(9388);const a={id:"es6",title:"ES6",sidebar_label:"ES6",sidebar_position:2},c=void 0,i={id:"react-native/es6",title:"ES6",description:"<AdFitMobileBanner",source:"@site/docs/react-native/es6.mdx",sourceDirName:"react-native",slug:"/react-native/es6",permalink:"/en/docs/current/react-native/es6",draft:!1,unlisted:!1,editUrl:"https://github.com/crossplatformkorea/crossplatformkorea.com/edit/main/docs/react-native/es6.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{id:"es6",title:"ES6",sidebar_label:"ES6",sidebar_position:2},sidebar:"react-native",previous:{title:"VSCode Plugins",permalink:"/en/docs/current/react-native/development-environment/vscode-plugins"},next:{title:"React",permalink:"/en/docs/current/react-native/react"}},l={},d=[{value:"1. let and const",id:"1-let-and-const",level:3},{value:"Block Scope",id:"block-scope",level:4},{value:"Hoisting",id:"hoisting",level:4},{value:"Reassignment",id:"reassignment",level:4},{value:"Redeclaration",id:"redeclaration",level:4},{value:"2. Arrow Functions",id:"2-arrow-functions",level:3},{value:"3. Classes",id:"3-classes",level:3},{value:"4. Template Literals",id:"4-template-literals",level:3},{value:"5. Destructuring Assignment",id:"5-destructuring-assignment",level:3},{value:"6. Default Parameters",id:"6-default-parameters",level:3},{value:"7. Spread Operator and Rest Parameters",id:"7-spread-operator-and-rest-parameters",level:3},{value:"Spread Operator",id:"spread-operator",level:4},{value:"Rest Parameters",id:"rest-parameters",level:4},{value:"8. Promises",id:"8-promises",level:3},{value:"9. Modules",id:"9-modules",level:3},{value:"10. Map and Set",id:"10-map-and-set",level:3},{value:"11. Symbols",id:"11-symbols",level:3},{value:"12. Iterators and Generators",id:"12-iterators-and-generators",level:3},{value:"13. Enhanced Object Literals",id:"13-enhanced-object-literals",level:3},{value:"14. Proxy and Reflection",id:"14-proxy-and-reflection",level:3},{value:"15. New Methods in Number, Math, Array, and Object",id:"15-new-methods-in-number-math-array-and-object",level:3},{value:"ES6 Array Methods",id:"es6-array-methods",level:2},{value:"1. <strong><code>map</code></strong>",id:"1-map",level:3},{value:"2. <strong><code>filter</code></strong>",id:"2-filter",level:3},{value:"3. <strong><code>reduce</code></strong>",id:"3-reduce",level:3},{value:"4. <strong><code>forEach</code></strong>",id:"4-foreach",level:3},{value:"5. <strong><code>find</code></strong>",id:"5-find",level:3},{value:"6. <strong><code>some</code></strong>",id:"6-some",level:3},{value:"7. <strong><code>every</code></strong>",id:"7-every",level:3}];function h(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.a)(),...e.components},{Details:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(o.Z,{unit:"DAN-YpcHf9p49U5ykXi8",className:"adfit-top-mobile"}),"\n",(0,r.jsxs)(n.p,{children:["In React Native, ",(0,r.jsx)(n.a,{href:"https://www.typescriptlang.org",children:"TypeScript"})," is the default language used. TypeScript is a superset of JavaScript that provides type support and includes useful ES6 syntax. Let's explore some of the basic TypeScript syntax while taking a look at the necessary ",(0,r.jsx)(n.a,{href:"https://www.w3schools.com/js/js_es6.asp",children:"ES6 features"})," for development."]}),"\n",(0,r.jsxs)(n.p,{children:["You can try out the following examples on the ",(0,r.jsx)(n.a,{href:"https://www.typescriptlang.org/play",children:"TypeScript Playground"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"1-let-and-const",children:"1. let and const"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"let x: number = 10;\nconst y: number = 20;\nconsole.log(x, y); // 10, 20\n"})}),"\n",(0,r.jsxs)(n.p,{children:["TypeScript allows you to specify types for variables. ",(0,r.jsx)(n.code,{children:"let"})," is used for mutable variables, while ",(0,r.jsx)(n.code,{children:"const"})," is used for constants that cannot be reassigned."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"let"})," and ",(0,r.jsx)(n.code,{children:"const"})," have significant differences compared to the old ",(0,r.jsx)(n.code,{children:"var"})," keyword:"]}),"\n",(0,r.jsx)(n.h4,{id:"block-scope",children:"Block Scope"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"var"})," has function scope, meaning it can be accessed from anywhere within a function. In contrast, ",(0,r.jsx)(n.code,{children:"let"})," and ",(0,r.jsx)(n.code,{children:"const"})," have block scope, meaning they can only be accessed within the block where they are declared (e.g., if statement, for loop)."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"hoisting",children:"Hoisting"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Variables declared with ",(0,r.jsx)(n.code,{children:"var"})," are hoisted to the top of their containing function, but variables declared with ",(0,r.jsx)(n.code,{children:"let"})," and ",(0,r.jsx)(n.code,{children:"const"})," are also hoisted but cannot be accessed before their declaration. Attempting to do so will result in a ReferenceError."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"reassignment",children:"Reassignment"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Variables declared with ",(0,r.jsx)(n.code,{children:"var"})," and ",(0,r.jsx)(n.code,{children:"let"})," can be reassigned, but variables declared with ",(0,r.jsx)(n.code,{children:"const"})," cannot be reassigned after their initial assignment."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"redeclaration",children:"Redeclaration"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"var"})," allows variables to be redeclared within the same scope, while ",(0,r.jsx)(n.code,{children:"let"})," and ",(0,r.jsx)(n.code,{children:"const"})," do not allow variable redeclaration in the same scope."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["These differences make ",(0,r.jsx)(n.code,{children:"let"})," and ",(0,r.jsx)(n.code,{children:"const"})," safer and promote more predictable code, especially by preventing confusing situations caused by ",(0,r.jsx)(n.code,{children:"var"})," hoisting."]}),"\n",(0,r.jsx)(n.h3,{id:"2-arrow-functions",children:"2. Arrow Functions"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const add: (a: number, b: number) => number = (a, b) => a + b;\nconsole.log(add(5, 3)); // 8\n"})}),"\n",(0,r.jsx)(n.p,{children:"Arrow functions allow you to specify types for parameters and return values."}),"\n",(0,r.jsxs)(n.p,{children:["Arrow functions in JavaScript resolve several limitations of functions defined using the ",(0,r.jsx)(n.code,{children:"function"})," keyword. The most significant difference is how the ",(0,r.jsx)(n.code,{children:"this"})," keyword behaves within arrow functions. In traditional functions, ",(0,r.jsx)(n.code,{children:"this"})," is bound based on how the function is called, leading to potential confusion. However, in arrow functions, ",(0,r.jsx)(n.code,{children:"this"})," always refers to the enclosing lexical scope. This ensures that ",(0,r.jsx)(n.code,{children:"this"})," works as expected in callback functions or closures, leading to more concise and clear code."]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"\"Lexical Scope\" refers to how the scope of variables and functions is determined by the structure of the code in the source file. In other words, lexical scope means that the scope of a variable is determined by where it's declared in the source code, not by how or when it's called during execution."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"3-classes",children:"3. Classes"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'class Person {\n  private name: string;\n\n  constructor(name: string) {\n    this.name = name;\n  }\n\n  public greet(): string {\n    return `Hello, ${this.name}`;\n  }\n}\n\nconst person: Person = new Person("Alice");\nconsole.log(person.greet()); // Hello, Alice\n'})}),"\n",(0,r.jsxs)(n.p,{children:["You can specify types for class properties and methods. Access modifiers like ",(0,r.jsx)(n.code,{children:"public"})," and ",(0,r.jsx)(n.code,{children:"private"})," can also be used."]}),"\n",(0,r.jsx)(n.h3,{id:"4-template-literals",children:"4. Template Literals"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'const name: string = "Bob";\nconsole.log(`Hello, ${name}`); // Hello, Bob\n'})}),"\n",(0,r.jsx)(n.p,{children:"You can specify types for string variables."}),"\n",(0,r.jsx)(n.h3,{id:"5-destructuring-assignment",children:"5. Destructuring Assignment"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const obj: { a: number; b: number } = { a: 1, b: 2 };\nconst { a, b }: { a: number; b: number } = obj;\nconsole.log(a, b); // 1, 2\n"})}),"\n",(0,r.jsx)(n.p,{children:"You can specify types when using destructuring assignment with objects."}),"\n",(0,r.jsx)(n.h3,{id:"6-default-parameters",children:"6. Default Parameters"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'function greet(name: string = "Guest"): string {\n  return `Hello, ${name}`;\n}\nconsole.log(greet()); // Hello, Guest\nconsole.log(greet("John")); // Hello, John\n'})}),"\n",(0,r.jsx)(n.p,{children:"You can specify types for function parameters and return values."}),"\n",(0,r.jsx)(n.h3,{id:"7-spread-operator-and-rest-parameters",children:"7. Spread Operator and Rest Parameters"}),"\n",(0,r.jsx)(n.h4,{id:"spread-operator",children:"Spread Operator"}),"\n",(0,r.jsx)(n.p,{children:"The spread operator is useful for copying and combining elements in arrays and objects."}),"\n",(0,r.jsxs)(s,{children:[(0,r.jsx)("summary",{children:"Example of Spread Operator with Objects"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const obj = { a: 1, b: 2 };\nconst newObj = { ...obj, c: 3 };\nconsole.log(newObj); // { a: 1, b: 2, c: 3 }\n"})}),(0,r.jsxs)(n.p,{children:["In this example, ",(0,r.jsx)(n.code,{children:"...obj"})," spreads the properties of ",(0,r.jsx)(n.code,{children:"obj"})," into a new object ",(0,r.jsx)(n.code,{children:"newObj"}),". This allows you to add new properties to the object without modifying the original object."]})]}),"\n",(0,r.jsxs)(s,{children:[(0,r.jsx)("summary",{children:"Example of Spread Operator with Arrays"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const nums = [1, 2, 3];\nconst moreNums = [...nums, 4, 5];\nconsole.log(moreNums); // [1, 2, 3, 4, 5]\n"})}),(0,r.jsxs)(n.p,{children:["In this example, ",(0,r.jsx)(n.code,{children:"...nums"})," spreads the elements of the ",(0,r.jsx)(n.code,{children:"nums"})," array into a new array ",(0,r.jsx)(n.code,{children:"moreNums"}),"."]})]}),"\n",(0,r.jsx)(n.h4,{id:"rest-parameters",children:"Rest Parameters"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"function sum(...numbers) {\n  let total = 0;\n  for (let number of numbers) {\n    total += number;\n  }\n  return total;\n}\n\nconsole.log(sum(1, 2, 3, 4, 5)); // 15\n"})}),"\n",(0,r.jsx)(n.p,{children:"Rest parameters allow you to accept a variable number of arguments as an array. This enables you to handle a dynamic number of parameters in a function."}),"\n",(0,r.jsx)(n.h3,{id:"8-promises",children:"8. Promises"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'const fetchData: Promise<string> = new Promise((resolve, reject) => {\n  // Perform asynchronous operation and then call resolve or reject\n  setTimeout(() => {\n    resolve("Data fetched successfully");\n    // Or reject with an error message\n    // reject("Error fetching data");\n  }, 1000);\n});\n\nfetchData\n  .then((data: string) => console.log(data)) // Log on success\n  .catch((error: string) => console.log(error)); // Log on error\n'})}),"\n",(0,r.jsxs)(n.p,{children:["You can specify the return type of Promises. In this example, ",(0,r.jsx)(n.code,{children:"Promise<string>"})," is declared."]}),"\n",(0,r.jsxs)(s,{children:[(0,r.jsx)("summary",{children:"Comparison with Callbacks"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"function getData(callback) {\n  setTimeout(() => {\n    callback('Sample Data');\n  }, 1000);\n}\n\ngetData((data) => {\n  console.log(data); // Sample Data\n});\n"})}),(0,r.jsx)(n.p,{children:"Using callbacks, you need to pass a callback function to handle asynchronous results. This approach can lead to complex nesting as the code grows."})]}),"\n",(0,r.jsx)(n.h3,{id:"9-modules",children:"9. Modules"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// math.ts\nexport const add = (a: number, b: number): number => a + b;\n\n// main.ts\nimport { add } from './math';\nconsole.log(add(\n\n5, 3)); // 8\n"})}),"\n",(0,r.jsx)(n.p,{children:"You can use modules in TypeScript and specify types for functions and variables within modules."}),"\n",(0,r.jsxs)(s,{children:[(0,r.jsx)("summary",{children:"Export Default and Named Exports"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// file: myModule.ts\nconst myFunction = (): void => {\n  console.log("Hello from myFunction");\n}\n\nexport default myFunction;\n'})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// file: main.ts\nimport myFunction from './myModule';\n\nmyFunction(); // Hello from myFunction\n"})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// file: myModule.ts\nexport const myFunction = (): void => {\n  console.log("Hello from myFunction");\n}\n\nexport const anotherFunction = (): void => {\n  console.log("Hello from anotherFunction");\n}\n'})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// file: main.ts\nimport { myFunction, anotherFunction } from './myModule';\n\nmyFunction(); // Hello from myFunction\nanotherFunction(); // Hello from anotherFunction\n"})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// file: main.ts\nimport * as myModule from './myModule';\n\nmyModule.myFunction();\nmyModule.anotherFunction();\n"})})]}),"\n",(0,r.jsx)(n.h3,{id:"10-map-and-set",children:"10. Map and Set"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"let map: Map<string, string> = new Map();\nmap.set('key', 'value');\nconsole.log(map.get('key')); // value\n\nlet set: Set<string> = new Set();\nset.add('item1');\nconsole.log(set.has('item1')); // true\n"})}),"\n",(0,r.jsxs)(n.p,{children:["You can specify types for the values stored in ",(0,r.jsx)(n.code,{children:"Map"})," and ",(0,r.jsx)(n.code,{children:"Set"}),"."]}),"\n",(0,r.jsxs)(s,{children:[(0,r.jsx)("summary",{children:"Usage of Map"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// Creating a Map\nlet map = new Map();\n\n// Adding key-value pairs\nmap.set('key1', 'value1');\nmap.set('key2', 'value2');\n\n// Accessing values by key\nconsole.log(map.get('key1')); // 'value1'\nconsole.log(map.get('key2')); // 'value2'\n\n// Checking for key existence\nconsole.log(map.has('key1')); // true\n\n// Getting the size of the map\nconsole.log(map.size); // 2\n\n// Clearing all key-value pairs\nmap.clear();\n\n// Checking the size after clearing\nconsole.log(map.size); // 0\n"})}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Map"})," is a collection that stores key-value pairs. Methods like ",(0,r.jsx)(n.code,{children:"set"}),", ",(0,r.jsx)(n.code,{children:"get"}),", ",(0,r.jsx)(n.code,{children:"has"}),", and ",(0,r.jsx)(n.code,{children:"clear"})," allow you to manage data in a ",(0,r.jsx)(n.code,{children:"Map"}),"."]})]}),"\n",(0,r.jsxs)(s,{children:[(0,r.jsx)("summary",{children:"Usage of Set"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// Creating a Set\nlet set = new Set();\n\n// Adding values\nset.add('value1');\nset.add('value2');\n\n// Checking for value existence\nconsole.log(set.has('value1')); // true\n\n// Getting the size of the set\nconsole.log(set.size); // 2\n\n// Deleting a value\nset.delete('value1');\n\n// Checking the size after deletion\nconsole.log(set.size); // 1\n\n// Clearing all values\nset.clear();\n\n// Checking the size after clearing\nconsole.log(set.size); // 0\n"})}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Set"})," is a collection that stores unique values. Methods like ",(0,r.jsx)(n.code,{children:"add"}),", ",(0,r.jsx)(n.code,{children:"has"}),", ",(0,r.jsx)(n.code,{children:"delete"}),", and ",(0,r.jsx)(n.code,{children:"clear"})," allow you to manage data in a ",(0,r.jsx)(n.code,{children:"Set"}),"."]})]}),"\n",(0,r.jsxs)(n.p,{children:["Both ",(0,r.jsx)(n.code,{children:"Map"})," and ",(0,r.jsx)(n.code,{children:"Set"})," are introduced in ES6 and provide efficient data management capabilities."]}),"\n",(0,r.jsx)(n.h3,{id:"11-symbols",children:"11. Symbols"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const sym: symbol = Symbol('description');\nconsole.log(sym); // Symbol(description)\n"})}),"\n",(0,r.jsx)(n.p,{children:"Symbols can be used in TypeScript, and you can specify their types."}),"\n",(0,r.jsxs)(s,{children:[(0,r.jsx)("summary",{children:"Usage of Symbols"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// Creating a symbol\nlet mySymbol = Symbol("mySymbolDescription");\n\n// Using a symbol as a property key in an object\nlet obj = {\n  [mySymbol]: "value"\n};\n\n// Accessing a property using a symbol key\nconsole.log(obj[mySymbol]); // "value"\n\n// Accessing the description of a symbol\nconsole.log(mySymbol.description); // "mySymbolDescription"\n\n// Creating another symbol with the same description - unique\nlet anotherSymbol = Symbol("mySymbolDescription");\nconsole.log(mySymbol === anotherSymbol); // false\n'})}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Symbol"})," is a unique and immutable data type used primarily as property keys in objects. Each ",(0,r.jsx)(n.code,{children:"Symbol"})," is unique, so even if two symbols have the same description, they are distinct."]})]}),"\n",(0,r.jsx)(n.p,{children:"Symbols provide a way to create unique values for object properties and can be helpful for scenarios where property names need to be distinct."}),"\n",(0,r.jsx)(n.h3,{id:"12-iterators-and-generators",children:"12. Iterators and Generators"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"function* generator(): Generator<number> {\n  yield 1;\n  yield 2;\n}\n\nconst gen: Generator<number> = generator();\nconsole.log(gen.next().value); // 1\nconsole.log(gen.next().value); // 2\n"})}),"\n",(0,r.jsx)(n.p,{children:"You can specify types for generator functions and iterators."}),"\n",(0,r.jsx)(n.h3,{id:"13-enhanced-object-literals",children:"13. Enhanced Object Literals"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const name: string = 'name';\nconst obj: { [key: string]: any; method: () => string } = {\n  [name]: 'value',\n  method(): string {\n    return this[name];\n  }\n};\nconsole.log(obj.method()); // value\n"})}),"\n",(0,r.jsx)(n.p,{children:"You can specify types for object literals and also define types for dynamic properties and methods."}),"\n",(0,r.jsx)(n.h3,{id:"14-proxy-and-reflection",children:"14. Proxy and Reflection"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"let target: any = {};\nlet proxy: ProxyHandler<any> = new Proxy(target, {\n  get(target: any, prop: string, receiver: any): any {\n    return Reflect.get(target, prop, receiver);\n  }\n});\nproxy.someProp = 'value';\nconsole.log(proxy.someProp); // value\n"})}),"\n",(0,r.jsxs)(n.p,{children:["You can apply types to ",(0,r.jsx)(n.code,{children:"Proxy"})," and ",(0,r.jsx)(n.code,{children:"Reflect"}),", allowing you to intercept and perform metaprogramming on object operations."]}),"\n",(0,r.jsx)(n.h3,{id:"15-new-methods-in-number-math-array-and-object",children:"15. New Methods in Number, Math, Array, and Object"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"console.log(Number.isInteger(42)); // true\nconsole.log(Math.log10(100)); // 2\nconsole.log(Array.from('hello')); // ['h', 'e', 'l', 'l', 'o']\nconsole.log(Object.assign({}, { a: 1 }, { b: 2 })); // { a: 1, b: 2 }\n"})}),"\n",(0,r.jsx)(n.p,{children:"In TypeScript, you can also use the new methods introduced in JavaScript for Number, Math, Array, and Object. This enhances type safety."}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"TypeScript provides static typing to increase code safety and catch many errors early during development. These features help developers write code that is more secure and efficient."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"es6-array-methods",children:"ES6 Array Methods"}),"\n",(0,r.jsxs)(n.p,{children:["ES6 introduced several useful methods for working with arrays, including ",(0,r.jsx)(n.code,{children:"map"}),", ",(0,r.jsx)(n.code,{children:"filter"}),", ",(0,r.jsx)(n.code,{children:"reduce"}),", and more. These methods are commonly used when dealing with data."]}),"\n",(0,r.jsxs)(n.h3,{id:"1-map",children:["1. ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"map"})})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const numbers: number[] = [1, 2, 3, 4, 5];\nconst squared: number[] = numbers.map(x => x * x);\nconsole.log(squared); // [1, 4, 9, 16, 25]\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"2-filter",children:["2. ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"filter"})})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const numbers: number[] = [1, 2, 3, 4, 5];\nconst even: number[] = numbers.filter(x => x % 2 === 0);\nconsole.log(even); // [2, 4]\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"3-reduce",children:["3. ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"reduce"})})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const numbers: number[] = [1, 2, 3, 4, 5];\nconst sum: number = numbers.reduce((acc: number, current: number) => acc + current, 0);\nconsole.log(sum); // 15\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"4-foreach",children:["4. ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"forEach"})})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const numbers: number[] = [1, 2, 3, 4, 5];\nnumbers.forEach((x: number) => console.log(x));\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"5-find",children:["5. ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"find"})})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const numbers: number[] = [1, 2, 3, 4, 5];\nconst firstEven: number | undefined = numbers.find(x => x % 2 === 0);\nconsole.log(firstEven); // 2\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"6-some",children:["6. ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"some"})})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const numbers: number[] = [1, 2, 3, 4, 5];\nconst hasEven: boolean = numbers.some(x => x % 2 === 0);\nconsole.log(hasEven); // true\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"7-every",children:["7. ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"every"})})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const numbers: number[] = [1, 2, 3, 4, 5];\nconst allEven: boolean = numbers.every(x => x % 2 === 0);\nconsole.log(allEven); // false\n"})}),"\n",(0,r.jsx)(n.p,{children:"With TypeScript, you can explicitly define the element types of arrays, increasing code safety and preventing type-related errors in advance."}),"\n",(0,r.jsx)(o.Z,{unit:"DAN-weLLBNA8C31gpo1t",className:"adfit-bottom-mobile"})]})}function u(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},7859:function(e,n,s){s.d(n,{Z:function(){return o}});var r=s(7294),t=s(5893);function o(e){let{className:n="adfit",style:s,unit:o,height:a,width:c}=e;return(0,r.useEffect)((()=>{const e=setTimeout((()=>{let e=document.createElement("ins"),s=document.createElement("script");e.className="kakao_ad_area",e.style="display:none; width:100%;",s.async="true",s.type="text/javascript",s.src="//t1.daumcdn.net/kas/static/ba.min.js",e.setAttribute("data-ad-width",c.toString()),e.setAttribute("data-ad-height",a.toString()),e.setAttribute("data-ad-unit",o.toString()),document.querySelector("."+n).appendChild(e),document.querySelector("."+n).appendChild(s)}),100);return()=>{clearTimeout(e)}}),[]),(0,t.jsx)("div",{style:s,children:(0,t.jsx)("div",{className:n})})}},9388:function(e,n,s){s.d(n,{Z:function(){return o}});s(7294);var r=s(7859),t=s(5893);function o(e){let{unit:n,className:s,height:o=100,width:a=320,style:c}=e;return(0,t.jsx)(r.Z,{unit:n,height:o,width:a,className:s,style:{flex:1,marginTop:24,marginBottom:24,...c}})}},1151:function(e,n,s){s.d(n,{Z:function(){return c},a:function(){return a}});var r=s(7294);const t={},o=r.createContext(t);function a(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);